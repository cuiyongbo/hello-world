**********************************
Standard Algorithm Library Note 02
**********************************

#. partition and stable_partition

    .. code-block:: cpp

        template<class ForwardIt, class UnaryPredicate>
        ForwardIt partition(ForwardIt first, ForwardIt last UnaryPredicate p)
        {
            first = std::find_if_not(first, last, p);
            if(first == last) return first;
            for(ForwardIt it=std::next(first); it != last; ++it)
            {
                if(p(*it))
                {
                    std::iter_swap(iter, first);
                    ++first;
                }
            }
            return first;
        }

    .. note::

        `partition` reorders the elements in the range `[first, last)` in such a way that all elements
        for which the predicate `p` returns `true` precede the elements for which predicate `p`
        returns `false`. `stable_partition` dittos, but keeps the relative order of elements.

#. partial_sum

    .. code-block:: cpp

        #include <numeric>

        template< class InputIt, class OutputIt >
        OutputIt partial_sum( InputIt first, InputIt last, OutputIt d_first );

        template< class InputIt, class OutputIt, class BinaryOperation >
        OutputIt partial_sum( InputIt first, InputIt last, OutputIt d_first,
                      BinaryOperation op );


    Computes the partial sums of the elements in the subranges of the range ``[first, last)``
    and writes them to the range beginning at ``d_first.`` The first version uses ``operator+``
    to sum up the elements, which is Equivalent  to:

    .. code-block:: cpp

        *(d_first)   = *first;
        *(d_first+1) = *first + *(first+1);
        *(d_first+2) = *first + *(first+1) + *(first+2);
        *(d_first+3) = *first + *(first+1) + *(first+2) + *(first+3);
        ...

#. accumulate

    .. code-block:: cpp

        #include <numeric>

        template< class InputIt, class T >
        T accumulate( InputIt first, InputIt last, T init );

        template< class InputIt, class T, class BinaryOperation >
        T accumulate( InputIt first, InputIt last, T init, BinaryOperation op );

    Computes the sum of the given value init and the elements in the range ``[first, last).``
    The first version uses ``operator+`` to sum up the elements,

#. transform

    .. code-block:: cpp

        #include <algorithm>

        template< class InputIt, class OutputIt, class UnaryOperation >
        OutputIt transform( InputIt first1, InputIt last1, OutputIt d_first,
                            UnaryOperation unary_op );

        template< class InputIt1, class InputIt2, class OutputIt, class BinaryOperation >
        OutputIt transform( InputIt1 first1, InputIt1 last1, InputIt2 first2,
                            OutputIt d_first, BinaryOperation binary_op )


    ``std::transform`` applies the given function to a range and stores the result
    in another range, beginning at ``d_first``.

    .. code-block:: cpp
        :caption: possible implementations

        template< class InputIt, class OutputIt, class UnaryOperation >
        OutputIt transform( InputIt first1, InputIt last1, OutputIt d_first,
                            UnaryOperation unary_op )
        {
            while(first1 != last1)
            {
                *d_first++ = unary_op(first1++);
            }
            return d_first;
        }


        template< class InputIt1, class InputIt2, class OutputIt, class BinaryOperation >
        OutputIt transform( InputIt1 first1, InputIt1 last1, InputIt2 first2,
                            OutputIt d_first, BinaryOperation binary_op )
        {
            while(first1 != last1)
            {
                *d_first++ = binary_op(first1++, first2++);
            }
            return d_first;
        }


#. iota

    .. code-block:: cpp

        #include <numeric>
        template< class ForwardIt, class T >
        void iota( ForwardIt first, ForwardIt last, T value );

    Fill the range ``[first, last)`` with sequentially increasing values, starting with *value*.

    .. code-block:: cpp
        :caption: Possible implementation

        template< class ForwardIt, class T >
        void iota( ForwardIt first, ForwardIt last, T value )
        {
            while(first != last)
            {
                *first++ = value;
                ++value;
            }
        }

    Usage: set ``vector<int>`` to a range

    .. code-block:: cpp

        // require c++11
        vector<int> v(14);
        std::iota(v.begin(), v.end(), 3);
        std::copy(v.begin(), v.end(), std::ostream_iterator<int>(cout, " "));
        cout << "\n";

#. generate

    .. code-block:: cpp

        #include<algorithm>

        template< class ForwardIt, class Generator >
        void generate( ForwardIt first, ForwardIt last, Generator g );

    Assign each element in range ``[first, last)`` a value generated by the given function object *g*,
    whose signature should be equivalent to ``Ret fun();`` The type *Ret* must be such that an object
    of type ``ForwardIt`` can be dereferenced and assigned a value of type *Ret*.â€‹

    .. code-block:: cpp
        :caption: Possible implementation

        template< class ForwardIt, class Generator >
        void generate( ForwardIt first, ForwardIt last, Generator g )
        {
            while(first != last)
            {
                *first++ = g();
            }
        }

#. all_of, any_of and none_of

    .. code-block:: cpp

        #include <algorithm>

        template<class InputIt, class UnaryPredicate>
        bool all_of(InputIt first, InputIt last, UnaryPredicate p);

        template<class InputIt, class UnaryPredicate>
        bool any_of(InputIt first, InputIt last, UnaryPredicate p);

        template<class InputIt, class UnaryPredicate>
        bool none_of(InputIt first, InputIt last, UnaryPredicate p);

    .. code-block:: none
        :caption: Possible implementations

        template<class InputIt, class UnaryPredicate>
        bool all_of( InputIt first, InputIt last, UnaryPredicate p)
        {
            return std::find_if_not(first, last, p) == last;
        }

        template<class InputIt, class UnaryPredicate>
        bool any_of(InputIt first, InputIt last, UnaryPredicate p)
        {
            return std::find_if(first, last, p) != last;
        }

        template<class InputIt, class UnaryPredicate>
        bool none_of(InputIt first, InputIt last, UnaryPredicate p)
        {
            return std::find_if(first, last, p) == last;
        }

    .. note::

        The expression ``p(v)`` must be convertible to bool for every argument v of
        type ``InputIt::value_type``, and must not modify v.
