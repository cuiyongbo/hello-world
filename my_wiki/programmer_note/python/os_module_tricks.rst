*********
os Module
*********

Frequently Used Methods
=======================

.. method:: getcwd()
   
   Return a string representing the current working directory.

.. method:: os.listdir(path)

   Return a list containing the names of the entries in the directory, *path*.
   The list is in arbitrary order.  It does not include the special
   entries ``'.'`` and ``'..'`` even if they are present in the directory.

.. method:: os.walk(top, topdown=True, onerror=None, followlinks=False)
  
   Directory tree generator.

   For each directory in the directory tree rooted at top (including top
   itself, but excluding ``'.'`` and ``'..'``), yields a 3-tuple
   
      ``(dirpath, dirnames, filenames)``. 

   *dirpath* is a string, the path to the directory.
   *dirnames* is a list of the names of the subdirectories
   in *dirpath* (excluding ``'.'`` and ``'..'``). *filenames* is a list of the
   names of the non-directory files in *dirpath*. Note that the names in the
   lists are just names, with no path components. To get a full path (which
   begins with top) to a file or directory in *dirpath*,
   do ``os.path.join(dirpath, name)``.

   If optional arg *topdown* is true or not specified, the triple for a
   directory is generated before the triples for any of its subdirectories
   (directories are generated top down).  If *topdown* is false, the triple
   for a directory is generated after the triples for all of its
   subdirectories (directories are generated bottom up).

   When *topdown* is true, the caller can modify the *dirnames* list in-place
   (e.g., via del or slice assignment), and walk will only recurse into the
   subdirectories whose names remain in *dirnames*; this can be used to prune the
   search, or to impose a specific order of visiting.  Modifying *dirnames* when
   *topdown* is false is ineffective, since the directories in *dirnames* have
   already been generated by the time *dirnames* itself is generated. No matter
   the value of *topdown*, the list of subdirectories is retrieved before the
   tuples for the directory and its subdirectories are generated.

   By default errors from the ``os.listdir()`` call are ignored.  If
   optional arg *onerror* is specified, it should be a function; it
   will be called with one argument, an ``os.error`` instance.  It can
   report the error to continue with the walk, or raise the exception
   to abort the walk.  Note that the filename is available as the
   filename attribute of the exception object.

   By default, os.walk does not follow symbolic links to subdirectories on
   systems that support them.  In order to get this functionality, set the
   optional argument 'followlinks' to true.

   Caution:  if you pass a relative pathname for top, don't change the
   current working directory between resumptions of walk.  walk never
   changes the current directory, and assumes that the client doesn't either.

   Example::

      import os
      from os.path import join, getsize
      for root, dirs, files in os.walk('python/Lib/email'):
         print root, "consumes",
         print sum([getsize(join(root, name)) for name in files]),
         print "bytes in", len(files), "non-directory files"
         if 'CVS' in dirs:
            dirs.remove('CVS')  # don't visit CVS directories

.. method:: os.path.walk(top, func, arg)

   For each directory in the directory tree rooted at top
   (including top itself, but excluding ``'.'`` and ``'..'``), 
   call ``func(arg, dirname, fnames)``. *dirname* is the name of the directory,
   and *fnames* a list of the names of the files and subdirectories in *dirname*
   (excluding ``'.'`` and ``'..'``).  *func* may modify the *fnames* list in-place
   (e.g. via del or slice assignment), and walk will only recurse into the
   subdirectories whose names remain in *fnames*; this can be used to implement
   a filter, or to impose a specific order of visiting. No semantics are defined
   for, or required of, *arg*, beyond that *arg* is always passed to *func*.
   It can be used, e.g., to pass a filename pattern, or a mutable object
   designed to accumulate statistics. Passing ``None`` for *arg* is common.

.. method:: os.chdir(path)

   Change the current working directory to the specified *path*.

.. method:: os.path.exists(path)

   Return ``True`` if path refers to an existing path. Returns ``False``
   for broken symbolic links. On some platforms, this function may
   return False if permission is not granted to execute ``os.stat()``
   on the requested file, even if the path physically exists.

.. method:: os.path.getsize(path)

   Return the size, in bytes, of path. Raise :exc:`os.error`
   if the file does not exist or is inaccessible.

   .. versionadded:: 1.5.2

.. method:: os.path.isabs(path)

   Return ``True`` if path is an absolute pathname.
   On Unix, that means it begins with a slash, on Windows
   that it begins with a (back)slash after chopping off
   a potential drive letter.

.. method:: os.path.isfile(path)

   Return ``True`` if *path* is an existing regular file.
   This follows symbolic links, so both :meth:`islink`
   and :meth:`isfile` can be true for the same path.

.. method:: os.path.isdir(path)

   Return ``True`` if *path* is an existing directory.
   This follows symbolic links, so both :meth:`islink`
   and :meth:`isdir` can be true for the same path.

.. method:: os.path.islink(path)

   Return ``True`` if *path* refers to a directory entry
   that is a symbolic link. Always ``False`` if symbolic
   links are not supported by the Python runtime.

.. method:: os.path.ismount(path)

   Return ``True`` if pathname *path* is a mount point:
   a point in a file system where a different file system
   has been mounted. The function checks whether path’s parent,
   ``path/..``, is on a different device than path,
   or whether ``path/..`` and *path* point to the same i-node
   on the same device — this should detect mount points for
   all Unix and POSIX variants.

.. method:: os.path.join(path, *paths)

   Join one or more path components intelligently.
   The return value is the concatenation of path and
   any members of *paths* with exactly one directory separator
   (``os.sep``) following each non-empty part except the last,
   meaning that the result will only end in a separator if the
   last part is empty. If a component is an absolute path,
   all previous components are thrown away and joining continues
   from the absolute path component.

   On Windows, the drive letter is not reset when an absolute path
   component (e.g., ``r'\foo'``) is encountered. If a component
   contains a drive letter, all previous components are thrown away
   and the drive letter is reset. Note that since there is a current
   directory for each drive, ``os.path.join("c:", "foo")`` represents
   a path relative to the current directory on drive
   ``C: (c:foo)``, not ``c:\foo``.

.. note:: 

   The return value is a number giving the number of seconds since the epoch
   (see the :mod:`time` module). Raise :exc:`os.error` if the file does not
   exist or is inaccessible.

.. method:: os.path.getatime(path)

   Return the time of last access of path. 

   .. versionadded:: 1.5.2

.. method:: os.path.getmtime(path)

   Return the time of last modification of path. 

   .. versionadded:: 1.5.2

.. method:: os.path.getctime(path)

   Return the system’s ctime which, on some systems
   (like Unix) is the time of the last metadata change,
   and, on others (like Windows), is the creation time
   for path. 

   .. versionadded:: 2.3


******************************
Python to traverse a directory
******************************

basically, there are two ways to traverse a specific directory:

   #. Using ``os.listdir()``.
      
   #. Using ``os.path.walk()``. (It will walk subdirectories recursively.)
      

Example

.. code-block:: python
   :caption: Traversing directory using ``os.listdir()``

   files = os.listdir(".")
   for file in files:
      doWork(file)


.. code-block:: python
   :caption: Traversing directory using ``os.path.walk()``

   def printFile(arg, dirname, fnames):
      print arg
      print dirname
      print fnames

   os.path.walk(".", printFile, None)


*************************
Python to traverse a file
*************************

.. code-block:: python
   :caption: Sample code

   with open(file) as src:
      for line in src:
         doWork(line)
      src.close()